# 동적계획법
# 메모리를 사용해서 수행시간 효율성을 비약적으로 향상시키는 기법
# 동적이란?
# - (일반적인 프로그래밍 분야)자료구조에서 동적할당(Dynamic Allocation)이란 '프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법'
# - 다이나믹프로그래밍에서 'Dynamic'은 별 의미 없이 사용됐음


# 사용할 수 있는 조건
# 1. 최적 부분 구조(Optimal Substructure) - 큰 문제를 작은 문제로 나눌 수 있음
# 2. 중복되는 부분 문제(Overlapping Subproblem) - 동일한 작은 문제를 반복적으로 해결해야함.

# ex) 피보나치 수열 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89
# 점화식(인접 항들 사이의 관계식) - a(n)=a(n-1) + a(n-2), a(1)=1, a(2)=1 -> 최적 부분구조 만족

def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x+2)


print(fibo(4))  # 3

# 해당 코드의 문제(단순 재귀함수로 해결)
# 지수 시간 복잡도 O(2^N) -> f(30)을 위해 10억 가량의 연산 수행
# f(2)가 여러번 호출 (중복되는 부분 문제) -> 중복되는 부분문제 만족
# =-> 한 번 해결한 문제는 기록하자.


#####################################################################
# 1.Top-Down(하향식)방식
# Memoization : 한 번 계산한 결과를 메모리 공간에 메모하는 기법
# 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
# 값을 기록해 놓는 다는 점에서 캐싱(Caching)이라고 합니다.

# 2. Bottom-Up(상향식)방식 - 전형적인 DP
# 결과 저장용 리스트는 DP테이블이라고 부른다.
####################################################################

# 피보나치 수열 Top-Down DP O(N)
d = [0] * 100  # 메모이제이션 용 리스트 초기화


def fibo_tb(x):
    # 종료조건
    if x == 1 or x == 2:
        return 1
    # 이미 계산했던 문제라면 반환(상수시간소비)
    if d[x] != 0:
        return d[x]

    # 아직 계산 전 문제라면 점화식제 따라 피보나치 결과 반환
    d[x] = fibo_tb(x-1) + fibo_tb(x-2)
    return d[x]


print(fibo_tb(99))


# 피보나치 수열 Bottom-up DP
d = [0] * 100

# 종료조건 대신에 첫 항들
d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]

print(d[n])


