# 동빈나 이코테 6.다이나믹 프로그래밍 (43:47)
# https://www.youtube.com/watch?v=5Lu34WIx2Us&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=6

# N가지 종류의 화폐가 있습니다.
# 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록하려고 합니다.
# 이 때, 각 종류의 화폐는 몇개라도 사용 가능합니다.
# 예를 들어, 2원 , 3월 단위의 화폐가 있을 때는 15원을 만들기 위해
# 3원을 5개 사용하는 것이 가장 최소 화폐 개수입니다.
# M원을 만들기 위한 최소한의 화폐 개수를 출력하는 프로그램을 작성하세요.

# 풀이시간 : 30분 | 시간제한 1초 | 메모리제한 128MB
# N은 화폐종류 개수, M은 가치의 합
# 둘째줄부터닌 화폐 가치

# 1<=N<=100 , 1<=M<=10000
# 최소 화폐 개수 출력, 불가능 시 -1 출력


# 실패함 ㅠㅠ

# 풀이
# a(i) = 금액 i를 만들 수 있는 최소한의 화폐 개수를
# k = 각 화폐의 단위

#  점화식 = 각 화폐 단위인 k를 하나씪 확인하며
#  a(i-k)를 만드는 방법이 존재하는 경우 , a(i) = min(a(i), a(i-k) + 1)
#  a(i-k)를 만드는 방법이 존재하지 않는 경우 a(i) = INF
# 시간 복잡도 O (NK)

# N=3, M=7 이고 화폐단위가 2,3,5인 경우

# step 0 (초기화)
# 각 인덱스에 해당하는 값으로 INF(무한) 값을 설정
# INF는 화폐 구성이 가능하지 않다는 의미
# 본 문제에서는 10001사용(M보다 큰 값)

# step 1
# 첫번째 화폐단위 2를 확인 (2의 배수 Index에 2*n = idx) n입력
# 두번째 화폐단위 3를 확인
# 3의 배수에 n입력 3*n = idx)
# idx-3에 값이 있으면 + 1  = (idx-3) + 1 ex)7은 7-3 = 4, 4는 2원짜리 2개 total = 3

# 세번째 화폐단위 5를 확인
# 5의 배수에 n입력 (5*n = idx)
# idx - 5에 값이 있으면 + 1  = (idx-5) + 1 ex) 7은 7-5=2 , 2는 2원짜리 1개 total = 2
# 기존 값인 3과 비교해서 더 작으니 2를 넣는다.

#res = 2

# 정수 n,m 입력
n, m = map(int, input().split())
# N개의 화폐 단위 정보를 입력받기
array = []
for i in range(n):
    array.append(int(input()))

d = [10001] * (m+1)
d[0] = 0

for curr in range(n):
    for i in range(array[curr], m+1):
        if d[i-array[curr]] != 10001:  # (i-k)을 만드는 방법이 존재하는 경우
            d[i] = min(d[i], d[i-array[curr]]+1)

if d[m] == 10001:  # 최종적으로 m원을 만드는 방법이 없는 경우
    print(-1)

else:
    print(d[m])
